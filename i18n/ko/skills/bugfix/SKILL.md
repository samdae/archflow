---
name: Bug Fix
description: Debug 모드에서 문서 기반 체계적 버그 수정. Triggers on "버그", "bugfix", "버그픽스", "에러 수정", "버그 수정". 요구사항/설계 문서와 런타임 에러 정보를 결합하여 원인 특정.
version: 2.0.0
---

# Bug Fix Workflow

Debug 모드의 런타임 컨텍스트와 문서를 결합하여 체계적으로 버그를 수정합니다.

## 💡 권장 모델

**Sonnet 먼저 시도** (Debug 모드가 에러 위치 제공 + 문서가 원래 동작 제공)

→ 복잡한 버그(여러 파일, 흐름 분석 필요)는 **Opus** 권장
→ 안 되면 Opus로 재시도

## 🔄 도구 폴백 (Fallback)

| 도구 | 없을 때 대체 방법 |
|------|-----------------|
| **Read/Grep** | 사용자에게 파일 경로 목록 요청 → 필요한 부분 복사-붙여넣기 요청 |
| **AskQuestion** | "다음 중 선택해주세요: 1) 옵션A 2) 옵션B 3) 옵션C" 형태로 질문 |
| **Debug 모드 없음** | 사용자에게 에러 로그/스택트레이스 직접 붙여넣기 요청 |

## ⚠️ 실행 환경

**Debug 모드에서 실행하세요.**

Debug 모드가 제공하는 런타임 정보(에러 로그, 스택트레이스, 변수 상태)와 문서를 결합해야 효과적입니다.

## 📁 문서 구조

```
projectRoot/
  └── docs/
        └── {serviceName}/
              ├── requirements.md   # require-refine 스킬 출력 (입력)
              ├── architect.md      # architect 스킬 출력 (입력)
              └── changelog.md      # ← 이 스킬의 출력
```

**serviceName 추론**: 입력 파일 경로 `docs/{serviceName}/requirements.md` 또는 `architect.md`에서 자동 추출

---

## Phase 0: 스킬 진입

### 0-0. 모델 및 환경 안내 (시작 시 출력)

> 💡 **이 스킬은 Debug 모드에서 실행해야 효과적입니다.**
> Debug 모드가 제공하는 에러 위치 + 문서의 원래 동작 정보를 결합합니다.
>
> **권장 모델**: Sonnet 먼저 시도, 복잡한 버그는 Opus
>
> **필요 문서** (`docs/{serviceName}/` 폴더):
> - requirements.md (필수)
> - architect.md (필수)
> - changelog.md (선택 - 없으면 이 세션에서 생성)

### 0-1. 문서 입력 받기

```json
{
  "title": "버그 픽스 시작",
  "questions": [
    {
      "id": "has_requirements",
      "prompt": "요구사항 문서가 있나요? (docs/{serviceName}/requirements.md)",
      "options": [
        {"id": "yes", "label": "예 - @파일경로로 알려드릴게요"},
        {"id": "no", "label": "아니오 - 없어요"}
      ]
    },
    {
      "id": "has_design",
      "prompt": "설계 문서가 있나요? (docs/{serviceName}/architect.md)",
      "options": [
        {"id": "yes", "label": "예 - @파일경로로 알려드릴게요"},
        {"id": "no", "label": "아니오 - 없어요"}
      ]
    },
    {
      "id": "has_changelog",
      "prompt": "변경 로그가 있나요? (docs/{serviceName}/changelog.md)",
      "options": [
        {"id": "yes", "label": "예 - @파일경로로 알려드릴게요"},
        {"id": "no", "label": "아니오 - 없어요 (완료 시 생성됨)"}
      ]
    }
  ]
}
```

**응답별 처리:**
- 요구사항 또는 설계 `no` → 아래 **일반 디버깅 모드** 안내
- 변경 로그 `no` → Phase 3에서 생성 예정으로 진행
- 모두 `yes` → 파일 경로 입력 요청 → Phase 1로 진행

### 일반 디버깅 모드 (문서 없을 때)

요구사항/설계 문서 없이 진행 시:

> ⚠️ **일반 디버깅 모드로 진행합니다.**
>
> 문서 기반 체계적 분석 없이, 에러 로그와 코드 분석만으로 버그를 수정합니다.
> - 원래 동작이 무엇인지 문서로 확인 불가
> - 설계 흐름 추적 불가
> - 수정 후 changelog 기록은 별도 파일에 저장
>
> 계속하시겠습니까?

**일반 디버깅 플로우:**
1. 에러 메시지/스택트레이스 분석
2. 관련 코드 Grep + Read
3. 원인 추정 → 사용자 확인
4. 수정 구현
5. changelog 저장 위치 별도 지정

### 0-2. serviceName 추론

입력받은 파일 경로에서 serviceName 추출:
- 입력: `docs/alert/requirements.md` 또는 `docs/alert/architect.md`
- 추출: `serviceName = "alert"`
- 출력 경로: `docs/alert/changelog.md`

### 0-3. 에러 정보 확인

Debug 모드에서 제공하는 정보 확인:
- 에러 메시지
- 스택트레이스 (에러 발생 위치)
- 관련 변수 상태 (있으면)

사용자에게 추가 정보 요청:
> "에러 상황을 설명해주세요. Debug 모드에서 보이는 에러 메시지나 스택트레이스가 있으면 함께 알려주세요."

---

## Phase 1: 문서 분석

### 1-1. 문서 로드

입력받은 문서들을 읽고 핵심 정보 파악:

| 문서 | 파악할 내용 |
|------|-----------|
| requirements.md | 원래 기대 동작, 정상 시나리오 |
| architect.md | 흐름 (어떤 순서로 호출되는지), Code Mapping |
| changelog.md | 최근 변경 사항 (버그 원인일 수 있음) |

### 1-2. 에러 위치와 설계 흐름 대조

```
에러 위치 (스택트레이스):
  예: alert_service.py:45 - NoneType error
        ↓
설계 문서 Code Mapping에서 해당 위치 확인:
  예: AlertService.create_alert() → user_id 처리
        ↓
요구사항에서 기대 동작 확인:
  예: "로그인 사용자의 알림 생성"
        ↓
불일치 지점 파악
```

### 1-3. 분석 결과 보고

```markdown
## 분석 결과

**에러 위치**: {파일}:{라인} - {에러 메시지}

**설계상 동작**:
- {설계 문서에서 해당 부분 흐름}

**요구사항상 기대 동작**:
- {요구사항에서 해당 기능 설명}

**최근 변경 사항** (변경 로그 있으면):
- {관련 있을 수 있는 최근 변경}

**추정 원인**:
- {원인 가설}

**확인 필요한 부분**:
- {추가 확인이 필요하면}
```

사용자에게 확인:
> "이 분석이 맞나요? 맞으면 수정을 진행합니다."

---

## Phase 2: 버그 수정

### 2-1. 원인 확정

분석 결과가 맞으면:
1. 해당 코드 위치 Read
2. 정확한 문제 지점 확인
3. 수정 방향 결정

### 2-2. 수정 구현

설계 문서의 원래 의도대로 수정:
- 요구사항에 맞게
- 설계 흐름에 맞게
- 기존 코드 스타일 유지

### 2-3. 수정 검증

Grep + Read로 수정된 코드 확인:
- 수정 적용됨?
- 설계 의도와 일치?

---

## Phase 3: changelogging 스킬 호출 (필수)

> ⚠️ **분석/수정 완료 후 반드시 changelogging 스킬을 호출하세요.**

### 3-1. changelogging 스킬 호출

분석/수정이 완료되면 **반드시** changelogging 스킬을 호출하여 결과를 기록합니다.

**호출 방법:**
> "changelogging 스킬을 호출하여 이 세션의 결과를 기록합니다."

또는 사용자에게 안내:
> "분석이 완료되었습니다. changelog에 기록하시겠습니까?"

### 3-2. 결과 유형에 따른 기록

| 결과 유형 | changelogging에서 기록할 내용 |
|----------|----------------------------|
| **코드 수정 완료** | 증상, 원인, 수정 내용, 설계 영향 |
| **외부 원인 파악** | 증상, 외부 원인, 권장 조치 |
| **조사 진행/실패** | 증상, 조사 내용, 다음 단계 |

### 3-3. 호출이 안 됐을 경우

사용자가 수동으로 호출 가능:
> "changelogging" 또는 "changelog 작성해줘"

같은 세션에서 호출하면 이전 대화의 컨텍스트(원인, 수정 내용 등)를 그대로 사용합니다.

---

## Phase 4: 완료 보고

```markdown
## 버그 픽스 완료

### 분석/수정 요약
| 항목 | 내용 |
|------|------|
| 증상 | {원래 버그 증상} |
| 원인 | {특정된 원인} |
| 결과 유형 | 코드 수정 / 외부 원인 / 조사 중 |
| 수정 파일 | {파일 목록 또는 "없음"} |

### 테스트 방법 (수정한 경우)
1. {재현 시나리오로 확인}
2. {정상 동작 확인 방법}

### 재발 방지 (필수 체크)
- [ ] 테스트 추가 (해당 시)
- [ ] 가드/검증 로직 추가 (해당 시)
- [ ] 로깅/모니터링 추가 (해당 시)

**같은 원인 재발 가능성**: 높음 / 중간 / 낮음
```

### changelogging 호출 확인

> ⚠️ **changelog에 기록하셨나요?**
> 
> 이 세션의 결과를 changelog에 기록하려면:
> - "changelogging" 스킬 호출
> - 또는 "changelog 작성해줘" 라고 요청
>
> **외부 원인이나 조사 실패도 기록 가치가 있습니다.**

---

# 연계

```
[require-refine] → docs/{serviceName}/requirements.md
        ↓
[architect] → docs/{serviceName}/architect.md
        ↓
[implement] → 구현
        ↓
(버그 발생)
        ↓
[bugfix] (Debug 모드) → 분석/수정
        ↓
[changelogging] → docs/{serviceName}/changelog.md
        ↓ (설계 영향 있을 때)
[architect-sync] → architect.md 동기화
```

---

# 주의사항

1. **Debug 모드 필수**
   - Debug 모드의 런타임 정보 없이는 효과 감소
   - 에러 위치, 스택트레이스가 핵심

2. **문서 의존성**
   - 요구사항/설계 문서가 정확해야 효과적
   - 문서와 구현이 불일치하면 먼저 동기화 필요

3. **변경 로그 관리**
   - 모든 버그 수정은 변경 로그에 기록
   - 추후 비슷한 버그 발생 시 참조 가능

4. **복잡한 버그**
   - 여러 파일에 걸친 버그는 Opus 권장
   - 한 번에 안 되면 분석 → 사용자 확인 → 재분석 반복
